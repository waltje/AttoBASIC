//
//AVRASM ver. 2.1.42  ATTINYBL.asm Sun Apr 27 17:13:02 2014
//
//ATTINYBL.asm(79): Including file 'tn85def.inc'
//ATTINYBL.asm(232): warning: Register r26 already defined by the .DEF directive
//ATTINYBL.asm(233): warning: Register r27 already defined by the .DEF directive
//ATTINYBL.asm(235): warning: Register r28 already defined by the .DEF directive
//ATTINYBL.asm(236): warning: Register r29 already defined by the .DEF directive
//ATTINYBL.asm(238): warning: Register r30 already defined by the .DEF directive
//ATTINYBL.asm(239): warning: Register r31 already defined by the .DEF directive
                // 
                // 
                // ; - This is my port of the t2313bl v0.8 bootloader by Arne Rossius to the attiny25/45/85
                // ; - It uses a modified version of the AVR305 Software UART
                // ; - I've added support for the AVR910 blockmode commands. This makes the bootloader bigger but faster.
                // ;
                // ;Features:
                // ; - automatic switching to main program if nothing is received within 1 second
                // ; - transparent to the application
                // ; - located at the end of the flash memory
                // ; - automatic modification of the application's Reset Vector while uploading
                // ; - AVR910 compatible protocol (see below for supported commands)
                // ;
                // ;Requirements:
                // ; - ATTiny25/45/85 running at any frequency which can provide a valid BAUD rate
                // ; - TTL RS232 interface connected to PB2/RxD and PB3/TxD in the target application
                // ; - The main (user) program MUST have a rjmp command at 0x000
                // ; - To make the bootloader as small as possible it it coded to use with avrdude.
                // ; - The default avrdude.conf file does not include unique avr910_devcode parameter for the
                // ;   attiny25/45/85. If you update avrdude.conf with the DevCode values from avr910_2313_v38c.asm
                // ;   I'm using in this file you will be able to use the avrdude "-t" option for the attiny24/45/85.
                // ;
                // ;Version:
                // ; v1.0 Initial release
                // ; v1.1 Disable the WDT in the initialization section. This needs to be done before jumping to the appln.
                // ;
                // ;
                // ;Programming commands (subset of avr910.asm from Atmel):
                // ;*                                     +-------------+-------------+------+
                // ;*  Commands                           | Host writes |  Host reads |      |
                // ;*  --------                           +-----+-------+-------+-----+      |
                // ;*                                     | ID  | data  |  data |     | Note |
                // ;* +-----------------------------------+-----+-------+-------+-----+------+
                // ;* | Enter programming mode            | 'P' |       |       | 13d |   1  |
                // ;* | Report autoincrement address      | 'a' |       |       | 'Y' |      |
                // ;* | Set address                       | 'A' | ah al |       | 13d |   2  |
                // ;* | Write program memory, low byte    | 'c' |    dd |       | 13d |   3  |
                // ;* | Write program memory, high byte   | 'C' |    dd |       | 13d |   3  |
                // ;* | Issue Page Write                  | 'm' |       |       | 13d |      |
                // ;* | Read program memory               | 'R' |       | dd(dd)|     |   4  |
                // ;* | Write data memory                 | 'D' |    dd |       | 13d |      |
                // ;* | Read data memory                  | 'd' |       |    dd |     |      |
                // ;* | Chip erase (excluding bootloader) | 'e' |       |       | 13d |      |
                // ;* | Leave programming mode            | 'L' |       |       | 13d |   5  |
                // ;* | Select device type (0x1a only)    | 'T' |    dd |       | 13d |   6  |
                // ;* | Return signature bytes (1E9108)   | 's' |       |  3*dd |     |      |
                // ;* | Return supported device code (1a) | 't' |       |  n*dd | 00d |   7  |
                // ;* | Return software ident. "utsrqp"   | 'S' |       |  s[7] |     |   8  |
                // ;* | Return sofware version            | 'V' |       | dd dd |     |   9  |
                // ;* | Return hardware version (0.0)     | 'v' |       | dd dd |     |   9  |
                // ;* | Return programmer type ("S")      | 'p' |       |    dd |     |  10  |
                // ;* +-----------------------------------+-----+-------+-------+-----+------+
                // ;* | New Commands since Version 3.5    |     |       |       |     |      |
                // ;* | Implemented Atmel Bootloader commands (Atmel Appl. Note 109)  |      |
                // ;* | Report Block write Mode           | 'b' |       |'Y'2*nn| 13d |  16  |
                // ;* | Block Write                       | 'B' |2*nn'M'|  n*dd | 13d |  16  |
                // ;* | Block Read                        | 'g' |2*nn'M'|  n*dd | 13d |  16  |
                // ;* +-----------------------------------+-----+-------+-------+-----+------+
                // 
                // 
                // 
                // 
                // ;**************************************************************************
                // ;*********************                                *********************
                // ;********************* Start of Configuration Section *********************
                // ;*********************                                *********************
                // ;**************************************************************************
                // 
                // 
                // ;**************************************************************************
                // ;*********************      Choose which attiny       *********************
                // ;**************************************************************************
                // 
                // ;.include "tn25def.inc"
                // ;.equ	DevCode = 0x1a ;AVR910 device code for ATTiny25 (from avr910_2313_v38c.asm)
                // 
                // ;.include "tn45def.inc"
                // ;.equ	DevCode = 0x1b ;AVR910 device code for ATTiny45 (from avr910_2313_v38c.asm)
                // 
                // .include "tn85def.inc"
                // 
                // ;***** Created: 2011-08-25 21:00 ******* Source: ATtiny85.xml ************
                // ;*************************************************************************
                // ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                // ;* 
                // ;* Number            : AVR000
                // ;* File Name         : "tn85def.inc"
                // ;* Title             : Register/Bit Definitions for the ATtiny85
                // ;* Date              : 2011-08-25
                // ;* Version           : 2.35
                // ;* Support E-mail    : avr@atmel.com
                // ;* Target MCU        : ATtiny85
                // ;* 
                // ;* DESCRIPTION
                // ;* When including this file in the assembly program file, all I/O register 
                // ;* names and I/O register bit names appearing in the data book can be used.
                // ;* In addition, the six registers forming the three data pointers X, Y and 
                // ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                // ;* SRAM is also defined 
                // ;* 
                // ;* The Register names are represented by their hexadecimal address.
                // ;* 
                // ;* The Register Bit names are represented by their bit number (0-7).
                // ;* 
                // ;* Please observe the difference in using the bit names with instructions
                // ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                // ;* (skip if bit in register set/cleared). The following example illustrates
                // ;* this:
                // ;* 
                // ;* in    r16,PORTB             ;read PORTB latch
                // ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                // ;* out   PORTB,r16             ;output to PORTB
                // ;* 
                // ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                // ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                // ;* rjmp  TOV0_is_set           ;jump if set
                // ;* ...                         ;otherwise do something else
                // ;*************************************************************************
                // 
                // #ifndef _TN85DEF_INC_
                // #define _TN85DEF_INC_
                // 
                // 
                // #pragma partinc 0
                // 
                // ; ***** SPECIFY DEVICE ***************************************************
                // .device ATtiny85
                // #pragma AVRPART ADMIN PART_NAME ATtiny85
                // .equ	SIGNATURE_000	= 0x1e
                // .equ	SIGNATURE_001	= 0x93
                // .equ	SIGNATURE_002	= 0x0b
                // 
                // #pragma AVRPART CORE CORE_VERSION V2
                // #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
                // 
                // 
                // ; ***** I/O REGISTER DEFINITIONS *****************************************
                // ; NOTE:
                // ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                // ; and cannot be used with IN/OUT instructions
                // .equ	SREG	= 0x3f
                // .equ	SPL	= 0x3d
                // .equ	SPH	= 0x3e
                // .equ	GIMSK	= 0x3b
                // .equ	GIFR	= 0x3a
                // .equ	TIMSK	= 0x39
                // .equ	TIFR	= 0x38
                // .equ	SPMCSR	= 0x37
                // .equ	MCUCR	= 0x35
                // .equ	MCUSR	= 0x34
                // .equ	TCCR0B	= 0x33
                // .equ	TCNT0	= 0x32
                // .equ	OSCCAL	= 0x31
                // .equ	TCCR1	= 0x30
                // .equ	TCNT1	= 0x2f
                // .equ	OCR1A	= 0x2e
                // .equ	OCR1C	= 0x2d
                // .equ	GTCCR	= 0x2c
                // .equ	OCR1B	= 0x2b
                // .equ	TCCR0A	= 0x2a
                // .equ	OCR0A	= 0x29
                // .equ	OCR0B	= 0x28
                // .equ	PLLCSR	= 0x27
                // .equ	CLKPR	= 0x26
                // .equ	DT1A	= 0x25
                // .equ	DT1B	= 0x24
                // .equ	DTPS	= 0x23
                // .equ	DWDR	= 0x22
                // .equ	WDTCR	= 0x21
                // .equ	PRR	= 0x20
                // .equ	EEARH	= 0x1f
                // .equ	EEARL	= 0x1e
                // .equ	EEDR	= 0x1d
                // .equ	EECR	= 0x1c
                // .equ	PORTB	= 0x18
                // .equ	DDRB	= 0x17
                // .equ	PINB	= 0x16
                // .equ	PCMSK	= 0x15
                // .equ	DIDR0	= 0x14
                // .equ	GPIOR2	= 0x13
                // .equ	GPIOR1	= 0x12
                // .equ	GPIOR0	= 0x11
                // .equ	USIBR	= 0x10
                // .equ	USIDR	= 0x0f
                // .equ	USISR	= 0x0e
                // .equ	USICR	= 0x0d
                // .equ	ACSR	= 0x08
                // .equ	ADMUX	= 0x07
                // .equ	ADCSRA	= 0x06
                // .equ	ADCH	= 0x05
                // .equ	ADCL	= 0x04
                // .equ	ADCSRB	= 0x03
                // 
                // 
                // ; ***** BIT DEFINITIONS **************************************************
                // 
                // ; ***** PORTB ************************
                // ; PORTB - Data Register, Port B
                // .equ	PORTB0	= 0	; 
                // .equ	PB0	= 0	; For compatibility
                // .equ	PORTB1	= 1	; 
                // .equ	PB1	= 1	; For compatibility
                // .equ	PORTB2	= 2	; 
                // .equ	PB2	= 2	; For compatibility
                // .equ	PORTB3	= 3	; 
                // .equ	PB3	= 3	; For compatibility
                // .equ	PORTB4	= 4	; 
                // .equ	PB4	= 4	; For compatibility
                // .equ	PORTB5	= 5	; 
                // .equ	PB5	= 5	; For compatibility
                // 
                // ; DDRB - Data Direction Register, Port B
                // .equ	DDB0	= 0	; 
                // .equ	DDB1	= 1	; 
                // .equ	DDB2	= 2	; 
                // .equ	DDB3	= 3	; 
                // .equ	DDB4	= 4	; 
                // .equ	DDB5	= 5	; 
                // 
                // ; PINB - Input Pins, Port B
                // .equ	PINB0	= 0	; 
                // .equ	PINB1	= 1	; 
                // .equ	PINB2	= 2	; 
                // .equ	PINB3	= 3	; 
                // .equ	PINB4	= 4	; 
                // .equ	PINB5	= 5	; 
                // 
                // 
                // ; ***** ANALOG_COMPARATOR ************
                // ; ADCSRB - ADC Control and Status Register B
                // .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                // 
                // ; ACSR - Analog Comparator Control And Status Register
                // .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                // .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                // .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                // .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                // .equ	ACO	= 5	; Analog Compare Output
                // .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                // .equ	AINBG	= ACBG	; For compatibility
                // .equ	ACD	= 7	; Analog Comparator Disable
                // 
                // ; DIDR0 - 
                // .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                // .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                // 
                // 
                // ; ***** AD_CONVERTER *****************
                // ; ADMUX - The ADC multiplexer Selection Register
                // .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                // .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                // .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                // .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                // .equ	REFS2	= 4	; Reference Selection Bit 2
                // .equ	ADLAR	= 5	; Left Adjust Result
                // .equ	REFS0	= 6	; Reference Selection Bit 0
                // .equ	REFS1	= 7	; Reference Selection Bit 1
                // 
                // ; ADCSRA - The ADC Control and Status register
                // .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                // .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                // .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                // .equ	ADIE	= 3	; ADC Interrupt Enable
                // .equ	ADIF	= 4	; ADC Interrupt Flag
                // .equ	ADATE	= 5	; ADC Auto Trigger Enable
                // .equ	ADSC	= 6	; ADC Start Conversion
                // .equ	ADEN	= 7	; ADC Enable
                // 
                // ; ADCH - ADC Data Register High Byte
                // .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                // .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                // .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                // .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                // .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                // .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                // .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                // .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                // 
                // ; ADCL - ADC Data Register Low Byte
                // .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                // .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                // .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                // .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                // .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                // .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                // .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                // .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                // 
                // ; ADCSRB - ADC Control and Status Register B
                // .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                // .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                // .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                // .equ	IPR	= 5	; Input Polarity Mode
                // .equ	BIN	= 7	; Bipolar Input Mode
                // 
                // ; DIDR0 - Digital Input Disable Register 0
                // .equ	ADC1D	= 2	; ADC1 Digital input Disable
                // .equ	ADC3D	= 3	; ADC3 Digital input Disable
                // .equ	ADC2D	= 4	; ADC2 Digital input Disable
                // .equ	ADC0D	= 5	; ADC0 Digital input Disable
                // 
                // 
                // ; ***** USI **************************
                // ; USIBR - USI Buffer Register
                // .equ	USIBR0	= 0	; USI Buffer Register bit 0
                // .equ	USIBR1	= 1	; USI Buffer Register bit 1
                // .equ	USIBR2	= 2	; USI Buffer Register bit 2
                // .equ	USIBR3	= 3	; USI Buffer Register bit 3
                // .equ	USIBR4	= 4	; USI Buffer Register bit 4
                // .equ	USIBR5	= 5	; USI Buffer Register bit 5
                // .equ	USIBR6	= 6	; USI Buffer Register bit 6
                // .equ	USIBR7	= 7	; USI Buffer Register bit 7
                // 
                // ; USIDR - USI Data Register
                // .equ	USIDR0	= 0	; USI Data Register bit 0
                // .equ	USIDR1	= 1	; USI Data Register bit 1
                // .equ	USIDR2	= 2	; USI Data Register bit 2
                // .equ	USIDR3	= 3	; USI Data Register bit 3
                // .equ	USIDR4	= 4	; USI Data Register bit 4
                // .equ	USIDR5	= 5	; USI Data Register bit 5
                // .equ	USIDR6	= 6	; USI Data Register bit 6
                // .equ	USIDR7	= 7	; USI Data Register bit 7
                // 
                // ; USISR - USI Status Register
                // .equ	USICNT0	= 0	; USI Counter Value Bit 0
                // .equ	USICNT1	= 1	; USI Counter Value Bit 1
                // .equ	USICNT2	= 2	; USI Counter Value Bit 2
                // .equ	USICNT3	= 3	; USI Counter Value Bit 3
                // .equ	USIDC	= 4	; Data Output Collision
                // .equ	USIPF	= 5	; Stop Condition Flag
                // .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
                // .equ	USISIF	= 7	; Start Condition Interrupt Flag
                // 
                // ; USICR - USI Control Register
                // .equ	USITC	= 0	; Toggle Clock Port Pin
                // .equ	USICLK	= 1	; Clock Strobe
                // .equ	USICS0	= 2	; USI Clock Source Select Bit 0
                // .equ	USICS1	= 3	; USI Clock Source Select Bit 1
                // .equ	USIWM0	= 4	; USI Wire Mode Bit 0
                // .equ	USIWM1	= 5	; USI Wire Mode Bit 1
                // .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
                // .equ	USISIE	= 7	; Start Condition Interrupt Enable
                // 
                // 
                // ; ***** EXTERNAL_INTERRUPT ***********
                // ; MCUCR - MCU Control Register
                // .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                // .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                // 
                // ; GIMSK - General Interrupt Mask Register
                // .equ	GICR	= GIMSK	; For compatibility
                // .equ	PCIE	= 5	; Pin Change Interrupt Enable
                // .equ	INT0	= 6	; External Interrupt Request 0 Enable
                // 
                // ; GIFR - General Interrupt Flag register
                // .equ	PCIF	= 5	; Pin Change Interrupt Flag
                // .equ	INTF0	= 6	; External Interrupt Flag 0
                // 
                // ; PCMSK - Pin Change Enable Mask
                // .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
                // .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
                // .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
                // .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
                // .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
                // .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
                // 
                // 
                // ; ***** EEPROM ***********************
                // ; EEARL - EEPROM Address Register Low Byte
                // .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                // .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                // .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                // .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                // .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                // .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                // .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                // .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                // 
                // ; EEARH - EEPROM Address Register High Byte
                // .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 0
                // 
                // ; EEDR - EEPROM Data Register
                // .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                // .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                // .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                // .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                // .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                // .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                // .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                // .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                // 
                // ; EECR - EEPROM Control Register
                // .equ	EERE	= 0	; EEPROM Read Enable
                // .equ	EEPE	= 1	; EEPROM Write Enable
                // .equ	EEMPE	= 2	; EEPROM Master Write Enable
                // .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                // .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                // .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                // 
                // 
                // ; ***** WATCHDOG *********************
                // ; WDTCR - Watchdog Timer Control Register
                // .equ	WDTCSR	= WDTCR	; For compatibility
                // .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                // .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                // .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                // .equ	WDE	= 3	; Watch Dog Enable
                // .equ	WDCE	= 4	; Watchdog Change Enable
                // .equ	WDTOE	= WDCE	; For compatibility
                // .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                // .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                // .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                // 
                // 
                // ; ***** TIMER_COUNTER_0 **************
                // ; TIMSK - Timer/Counter Interrupt Mask Register
                // .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                // .equ	OCIE0B	= 3	; Timer/Counter0 Output Compare Match B Interrupt Enable
                // .equ	OCIE0A	= 4	; Timer/Counter0 Output Compare Match A Interrupt Enable
                // 
                // ; TIFR - Timer/Counter0 Interrupt Flag register
                // .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                // .equ	OCF0B	= 3	; Timer/Counter0 Output Compare Flag 0B
                // .equ	OCF0A	= 4	; Timer/Counter0 Output Compare Flag 0A
                // 
                // ; TCCR0A - Timer/Counter  Control Register A
                // .equ	WGM00	= 0	; Waveform Generation Mode
                // .equ	WGM01	= 1	; Waveform Generation Mode
                // .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                // .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                // .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                // .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                // 
                // ; TCCR0B - Timer/Counter Control Register B
                // .equ	CS00	= 0	; Clock Select
                // .equ	CS01	= 1	; Clock Select
                // .equ	CS02	= 2	; Clock Select
                // .equ	WGM02	= 3	; 
                // .equ	FOC0B	= 6	; Force Output Compare B
                // .equ	FOC0A	= 7	; Force Output Compare A
                // 
                // ; TCNT0 - Timer/Counter0
                // .equ	TCNT0_0	= 0	; 
                // .equ	TCNT0_1	= 1	; 
                // .equ	TCNT0_2	= 2	; 
                // .equ	TCNT0_3	= 3	; 
                // .equ	TCNT0_4	= 4	; 
                // .equ	TCNT0_5	= 5	; 
                // .equ	TCNT0_6	= 6	; 
                // .equ	TCNT0_7	= 7	; 
                // 
                // ; OCR0A - Timer/Counter0 Output Compare Register
                // .equ	OCR0_0	= 0	; 
                // .equ	OCR0_1	= 1	; 
                // .equ	OCR0_2	= 2	; 
                // .equ	OCR0_3	= 3	; 
                // .equ	OCR0_4	= 4	; 
                // .equ	OCR0_5	= 5	; 
                // .equ	OCR0_6	= 6	; 
                // .equ	OCR0_7	= 7	; 
                // 
                // ; OCR0B - Timer/Counter0 Output Compare Register
                // ;.equ	OCR0_0	= 0	; 
                // ;.equ	OCR0_1	= 1	; 
                // ;.equ	OCR0_2	= 2	; 
                // ;.equ	OCR0_3	= 3	; 
                // ;.equ	OCR0_4	= 4	; 
                // ;.equ	OCR0_5	= 5	; 
                // ;.equ	OCR0_6	= 6	; 
                // ;.equ	OCR0_7	= 7	; 
                // 
                // ; GTCCR - General Timer/Counter Control Register
                // .equ	PSR0	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                // .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                // 
                // 
                // ; ***** TIMER_COUNTER_1 **************
                // ; TCCR1 - Timer/Counter Control Register
                // .equ	CS10	= 0	; Clock Select Bits
                // .equ	CS11	= 1	; Clock Select Bits
                // .equ	CS12	= 2	; Clock Select Bits
                // .equ	CS13	= 3	; Clock Select Bits
                // .equ	COM1A0	= 4	; Compare Output Mode, Bit 1
                // .equ	COM1A1	= 5	; Compare Output Mode, Bit 0
                // .equ	PWM1A	= 6	; Pulse Width Modulator Enable
                // .equ	CTC1	= 7	; Clear Timer/Counter on Compare Match
                // 
                // ; TCNT1 - Timer/Counter Register
                // .equ	TCNT1_0	= 0	; Timer/Counter Register Bit 0
                // .equ	TCNT1_1	= 1	; Timer/Counter Register Bit 1
                // .equ	TCNT1_2	= 2	; Timer/Counter Register Bit 2
                // .equ	TCNT1_3	= 3	; Timer/Counter Register Bit 3
                // .equ	TCNT1_4	= 4	; Timer/Counter Register Bit 4
                // .equ	TCNT1_5	= 5	; Timer/Counter Register Bit 5
                // .equ	TCNT1_6	= 6	; Timer/Counter Register Bit 6
                // .equ	TCNT1_7	= 7	; Timer/Counter Register Bit 7
                // 
                // ; OCR1A - Output Compare Register
                // .equ	OCR1A0	= 0	; Output Compare Register A Bit 0
                // .equ	OCR1A1	= 1	; Output Compare Register A Bit 1
                // .equ	OCR1A2	= 2	; Output Compare Register A Bit 2
                // .equ	OCR1A3	= 3	; Output Compare Register A Bit 3
                // .equ	OCR1A4	= 4	; Output Compare Register A Bit 4
                // .equ	OCR1A5	= 5	; Output Compare Register A Bit 5
                // .equ	OCR1A6	= 6	; Output Compare Register A Bit 6
                // .equ	OCR1A7	= 7	; Output Compare Register A Bit 7
                // 
                // ; OCR1B - Output Compare Register
                // .equ	OCR1B0	= 0	; Output Compare Register B Bit 0
                // .equ	OCR1B1	= 1	; Output Compare Register B Bit 1
                // .equ	OCR1B2	= 2	; Output Compare Register B Bit 2
                // .equ	OCR1B3	= 3	; Output Compare Register B Bit 3
                // .equ	OCR1B4	= 4	; Output Compare Register B Bit 4
                // .equ	OCR1B5	= 5	; Output Compare Register B Bit 5
                // .equ	OCR1B6	= 6	; Output Compare Register B Bit 6
                // .equ	OCR1B7	= 7	; Output Compare Register B Bit 7
                // 
                // ; OCR1C - Output compare register
                // .equ	OCR1C0	= 0	; 
                // .equ	OCR1C1	= 1	; 
                // .equ	OCR1C2	= 2	; 
                // .equ	OCR1C3	= 3	; 
                // .equ	OCR1C4	= 4	; 
                // .equ	OCR1C5	= 5	; 
                // .equ	OCR1C6	= 6	; 
                // .equ	OCR1C7	= 7	; 
                // 
                // ; TIMSK - Timer/Counter Interrupt Mask Register
                // .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                // .equ	OCIE1B	= 5	; OCIE1A: Timer/Counter1 Output Compare B Interrupt Enable
                // .equ	OCIE1A	= 6	; OCIE1A: Timer/Counter1 Output Compare Interrupt Enable
                // 
                // ; TIFR - Timer/Counter Interrupt Flag Register
                // .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                // .equ	OCF1B	= 5	; Timer/Counter1 Output Compare Flag 1B
                // .equ	OCF1A	= 6	; Timer/Counter1 Output Compare Flag 1A
                // 
                // ; GTCCR - Timer counter control register
                // .equ	PSR1	= 1	; Prescaler Reset Timer/Counter1
                // .equ	FOC1A	= 2	; Force Output Compare 1A
                // .equ	FOC1B	= 3	; Force Output Compare Match 1B
                // .equ	COM1B0	= 4	; Comparator B Output Mode
                // .equ	COM1B1	= 5	; Comparator B Output Mode
                // .equ	PWM1B	= 6	; Pulse Width Modulator B Enable
                // 
                // ; DTPS - Dead time prescaler register
                // .equ	DTPS0	= 0	; 
                // .equ	DTPS1	= 1	; 
                // 
                // ; DT1A - Dead time value register
                // .equ	DTVL0	= 0	; 
                // .equ	DTVL1	= 1	; 
                // .equ	DTVL2	= 2	; 
                // .equ	DTVL3	= 3	; 
                // .equ	DTVH0	= 4	; 
                // .equ	DTVH1	= 5	; 
                // .equ	DTVH2	= 6	; 
                // .equ	DTVH3	= 7	; 
                // 
                // ; DT1B - Dead time value B
                // ;.equ	DTVL0	= 0	; 
                // ;.equ	DTVL1	= 1	; 
                // ;.equ	DTVL2	= 2	; 
                // ;.equ	DTVL3	= 3	; 
                // ;.equ	DTVH0	= 4	; 
                // ;.equ	DTVH1	= 5	; 
                // ;.equ	DTVH2	= 6	; 
                // ;.equ	DTVH3	= 7	; 
                // 
                // 
                // ; ***** BOOT_LOAD ********************
                // ; SPMCSR - Store Program Memory Control Register
                // .equ	SPMEN	= 0	; Store Program Memory Enable
                // .equ	PGERS	= 1	; Page Erase
                // .equ	PGWRT	= 2	; Page Write
                // .equ	RFLB	= 3	; Read fuse and lock bits
                // .equ	CTPB	= 4	; Clear temporary page buffer
                // 
                // 
                // ; ***** CPU **************************
                // ; SREG - Status Register
                // .equ	SREG_C	= 0	; Carry Flag
                // .equ	SREG_Z	= 1	; Zero Flag
                // .equ	SREG_N	= 2	; Negative Flag
                // .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                // .equ	SREG_S	= 4	; Sign Bit
                // .equ	SREG_H	= 5	; Half Carry Flag
                // .equ	SREG_T	= 6	; Bit Copy Storage
                // .equ	SREG_I	= 7	; Global Interrupt Enable
                // 
                // ; MCUCR - MCU Control Register
                // ;.equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                // ;.equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                // .equ	SM0	= 3	; Sleep Mode Select Bit 0
                // .equ	SM1	= 4	; Sleep Mode Select Bit 1
                // .equ	SE	= 5	; Sleep Enable
                // .equ	PUD	= 6	; Pull-up Disable
                // 
                // ; MCUSR - MCU Status register
                // .equ	PORF	= 0	; Power-On Reset Flag
                // .equ	EXTRF	= 1	; External Reset Flag
                // .equ	BORF	= 2	; Brown-out Reset Flag
                // .equ	WDRF	= 3	; Watchdog Reset Flag
                // 
                // ; PRR - Power Reduction Register
                // .equ	PRADC	= 0	; Power Reduction ADC
                // .equ	PRUSI	= 1	; Power Reduction USI
                // .equ	PRTIM0	= 2	; Power Reduction Timer/Counter0
                // .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                // 
                // ; OSCCAL - Oscillator Calibration Register
                // .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
                // .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
                // .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
                // .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
                // .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
                // .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
                // .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
                // .equ	CAL7	= 7	; Oscillatro Calibration Value Bit 7
                // 
                // ; PLLCSR - PLL Control and status register
                // .equ	PLOCK	= 0	; PLL Lock detector
                // .equ	PLLE	= 1	; PLL Enable
                // .equ	PCKE	= 2	; PCK Enable
                // .equ	LSM	= 7	; Low speed mode
                // 
                // ; CLKPR - Clock Prescale Register
                // .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                // .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                // .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                // .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                // .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                // 
                // ; DWDR - debugWire data register
                // .equ	DWDR0	= 0	; 
                // .equ	DWDR1	= 1	; 
                // .equ	DWDR2	= 2	; 
                // .equ	DWDR3	= 3	; 
                // .equ	DWDR4	= 4	; 
                // .equ	DWDR5	= 5	; 
                // .equ	DWDR6	= 6	; 
                // .equ	DWDR7	= 7	; 
                // 
                // ; GPIOR2 - General Purpose IO register 2
                // .equ	GPIOR20	= 0	; 
                // .equ	GPIOR21	= 1	; 
                // .equ	GPIOR22	= 2	; 
                // .equ	GPIOR23	= 3	; 
                // .equ	GPIOR24	= 4	; 
                // .equ	GPIOR25	= 5	; 
                // .equ	GPIOR26	= 6	; 
                // .equ	GPIOR27	= 7	; 
                // 
                // ; GPIOR1 - General Purpose register 1
                // .equ	GPIOR10	= 0	; 
                // .equ	GPIOR11	= 1	; 
                // .equ	GPIOR12	= 2	; 
                // .equ	GPIOR13	= 3	; 
                // .equ	GPIOR14	= 4	; 
                // .equ	GPIOR15	= 5	; 
                // .equ	GPIOR16	= 6	; 
                // .equ	GPIOR17	= 7	; 
                // 
                // ; GPIOR0 - General purpose register 0
                // .equ	GPIOR00	= 0	; 
                // .equ	GPIOR01	= 1	; 
                // .equ	GPIOR02	= 2	; 
                // .equ	GPIOR03	= 3	; 
                // .equ	GPIOR04	= 4	; 
                // .equ	GPIOR05	= 5	; 
                // .equ	GPIOR06	= 6	; 
                // .equ	GPIOR07	= 7	; 
                // 
                // 
                // 
                // ; ***** LOCKSBITS ********************************************************
                // .equ	LB1	= 0	; Lockbit
                // .equ	LB2	= 1	; Lockbit
                // 
                // 
                // ; ***** FUSES ************************************************************
                // ; LOW fuse bits
                // .equ	CKSEL0	= 0	; Select Clock source
                // .equ	CKSEL1	= 1	; Select Clock source
                // .equ	CKSEL2	= 2	; Select Clock source
                // .equ	CKSEL3	= 3	; Select Clock source
                // .equ	SUT0	= 4	; Select start-up time
                // .equ	SUT1	= 5	; Select start-up time
                // .equ	CKOUT	= 6	; Clock Output Enable
                // .equ	CKDIV8	= 7	; Divide clock by 8
                // 
                // ; HIGH fuse bits
                // .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                // .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                // .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                // .equ	EESAVE	= 3	; EEPROM memory is preserved through the Chip Erase
                // .equ	WDTON	= 4	; Watchdog Timer always on
                // .equ	SPIEN	= 5	; Enable Serial Program and Data Downloading
                // .equ	DWEN	= 6	; DebugWIRE Enable
                // .equ	RSTDISBL	= 7	; External Reset disable
                // 
                // ; EXTENDED fuse bits
                // .equ	SELFPRGEN	= 0	; Self-Programming Enable
                // 
                // 
                // 
                // ; ***** CPU REGISTER DEFINITIONS *****************************************
                // .def	XH	= r27
                // .def	XL	= r26
                // .def	YH	= r29
                // .def	YL	= r28
                // .def	ZH	= r31
                // .def	ZL	= r30
                // 
                // 
                // 
                // ; ***** DATA MEMORY DECLARATIONS *****************************************
                // .equ	FLASHEND	= 0x0fff	; Note: Word address
                // .equ	IOEND	= 0x003f
                // .equ	SRAM_START	= 0x0060
                // .equ	SRAM_SIZE	= 512
                // .equ	RAMEND	= 0x025f
                // .equ	XRAMEND	= 0x0000
                // .equ	E2END	= 0x01ff
                // .equ	EEPROMEND	= 0x01ff
                // .equ	EEADRBITS	= 9
                // #pragma AVRPART MEMORY PROG_FLASH 8192
                // #pragma AVRPART MEMORY EEPROM 512
                // #pragma AVRPART MEMORY INT_SRAM SIZE 512
                // #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                // 
                // 
                // 
                // ; ***** BOOTLOADER DECLARATIONS ******************************************
                // .equ	NRWW_START_ADDR	= 0x0
                // .equ	NRWW_STOP_ADDR	= 0xfff
                // .equ	RWW_START_ADDR	= 0x0
                // .equ	RWW_STOP_ADDR	= 0x0
                // .equ	PAGESIZE	= 32
                // 
                // 
                // 
                // ; ***** INTERRUPT VECTORS ************************************************
                // .equ	INT0addr	= 0x0001	; External Interrupt 0
                // .equ	PCI0addr	= 0x0002	; Pin change Interrupt Request 0
                // .equ	OC1Aaddr	= 0x0003	; Timer/Counter1 Compare Match 1A
                // .equ	OVF1addr	= 0x0004	; Timer/Counter1 Overflow
                // .equ	OVF0addr	= 0x0005	; Timer/Counter0 Overflow
                // .equ	ERDYaddr	= 0x0006	; EEPROM Ready
                // .equ	ACIaddr	= 0x0007	; Analog comparator
                // .equ	ADCCaddr	= 0x0008	; ADC Conversion ready
                // .equ	OC1Baddr	= 0x0009	; Timer/Counter1 Compare Match B
                // .equ	OC0Aaddr	= 0x000a	; Timer/Counter0 Compare Match A
                // .equ	OC0Baddr	= 0x000b	; Timer/Counter0 Compare Match B
                // .equ	WDTaddr	= 0x000c	; Watchdog Time-out
                // .equ	USI_STARTaddr	= 0x000d	; USI START
                // .equ	USI_OVFaddr	= 0x000e	; USI Overflow
                // 
                // .equ	INT_VECTORS_SIZE	= 15	; size in words
                // 
                // #endif  /* _TN85DEF_INC_ */
                // 
                // ; ***** END OF FILE ******************************************************
                // .equ	DevCode = 0x1c ;AVR910 device code for ATTiny85 (from avr910_2313_v38c.asm)
                // 
                // 
                // ;**************************************************************************
                // ;******************* Configure the AVR305 Software UART *******************
                // ;**************************************************************************
                // 
                // ;Pin definitions
                // .equ	RxD	=0	;Receive pin is PB0
                // .equ	TxD	=1	;Transmit pin is PB1
                // 
                // ;Enter the Freq you are running the processor at, the Baud rate and number of stop bits you want
                // ;.equ	Freq = 1000000	;clock frequency
                // .equ	Freq = 8000000	;clock frequency
                // ;.equ	Baud = 28800	;baud rate
                // .equ	Baud = 19200	;baud rate
                // .equ	sb   = 1		;Number of stop bits (1, 2, ...)
                // 
                // ; Valid Baud rates for the Internal Oscillator (See AVR305 for more frequencies and their Baud rates)
                // ;     Clock:  1 MHz  2 MHz  4 MHz  8MHz
                // ;   2400 bps  b=66   b=135
                // ;   4800 bps  b=31   b=66   b=135
                // ;   9600 bps  b=14   b=31   b=66   b=135
                // ;  14400 bps  b=8    b=19   b=42   b=89
                // ;  19200 bps  b=5    b=14   b=31   b=66
                // ;  28800 bps  b=2    b=8    b=19   b=42
                // ;  38400 bps         b=5    b=14   b=31
                // ;  57600 bps         b=2    b=8    b=19
                // ; 115200 bps                b=2    b=8
                // ; 230400 bps                       b=2
                // 
                // ;The AVR305 "b" value is calculated for you based on the Freq & Baud you choose.
                // ;Freq & Baud must be valid values from AVR305 so that the value for b will fit into an 8-bit register:
                // ;- Baud rates which are too low will error "Operand(s) out of range in 'ld1 r17,0xNNN" and NNN will be > 256
                // ;- Baud rates which are too high will not error as they load a small negative value into b, which won't work
                // .equ	b	= ((Freq/(Baud/2))-39)/12
                // 
                // 
                // ;**************************************************************************
                // ;********************* Choose your bootloader features ********************
                // ;**************************************************************************
                // 
                // .equ	BLKMODE = 1
                // ;       BLKMODE = 0      - Only include bytemode cmds for both flash and eeprom -> Smaller
                // ;       BLKMODE = 1      - Only include blockmode commands for both flash and eeprom -> Faster
                // 
                // .equ	EEPROM  = 0
                // ;       EEPROM  = 0      - Don't include the EEPROM cmds -> Smaller again
                // ;       EEPROM  = 1      - Include the EEPROM cmds
                // 
                // .equ	AVRDUDE_Y = 0
                // ;       AVRDUDE_Y = 0    - Avrdude -y & -Y not supported
                // ;       AVRDUDE_Y = 1    - Avrdude -y & -Y supported. Bytemode eeprom cmds included, even when EEPROM=0
                // 
                // 
                // ;**************************************************************************
                // ;*********************                                *********************
                // ;*********************  End of Configuration Section  *********************
                // ;*********************                                *********************
                // ;**************************************************************************
                // 
                // 
                // 
                // .equ	VerMaj = 1	;major version number
                // .equ	VerMin = 0	;minor version number
                // 
                // ;You only need to change this if you have changed the bootloader code.
                // .if   ( PAGESIZE == 16 )			; ATTiny25 (Code size/Bootloader size in 16 word pages)
                // 	.if ( BLKMODE )
                // 		.if ( EEPROM )
                // 			.if ( AVRDUDE_Y )
                // 			.else
                // 			.endif
                // 		.else
                // 			.if ( AVRDUDE_Y )
                // 			.else
                // 			.endif
                // 		.endif
                // 	.else
                // 		.if ( EEPROM ) || ( AVRDUDE_Y )
                // 		.else
                // 		.endif
                // 	.endif
                // .else								; ATTiny45/85 (Code size/Bootloader size in 32 word pages)
                // 	.if ( BLKMODE )
                // 		.if ( EEPROM )
                // 			.if ( AVRDUDE_Y )
                // 			.else
                // 			.endif
                // 		.else
                // 			.if ( AVRDUDE_Y )
                // 			.else
                // 				.equ	BLSIZE = 8	;(454/512) Blockmode FLASH cmds
                // 			.endif
                // 		.endif
                // 	.else
                // 		.if ( EEPROM ) || ( AVRDUDE_Y )
                // 		.else
                // 		.endif
                // 	.endif
                // .endif
                // 
                // ;Size of the buffer to use as the receive buffer for block write commands
                // ;- Must be an integer multple of the pagesize
                // .equ BUFSIZE  = SRAM_SIZE - 0x40	; Use all but last 0xNN bytes of internal RAM
                // 
                // .if ( BUFSIZE%PAGESIZE > 0 )
                // .endif
                // 
                // 
                // .equ WATCHDOG_OFF    = 0x00
                // .equ WATCHDOG_16MS   = (1<<WDE)
                // .equ WATCHDOG_32MS   = (1<<WDP0) | (1<<WDE)
                // .equ WATCHDOG_64MS   = (1<<WDP1) | (1<<WDE)
                // .equ WATCHDOG_125MS  = (1<<WDP1) | (1<<WDP0) | (1<<WDE)
                // .equ WATCHDOG_250MS  = (1<<WDP2) | (1<<WDE)
                // .equ WATCHDOG_500MS  = (1<<WDP2) | (1<<WDP0) | (1<<WDE)
                // .equ WATCHDOG_1S     = (1<<WDP2) | (1<<WDP1) | (1<<WDE)
                // .equ WATCHDOG_2S     = (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)
                // .equ WATCHDOG_4S     = (1<<WDP3) | (1<<WDE)
                // .equ WATCHDOG_8S     = (1<<WDP3) | (1<<WDP0) | (1<<WDE)
                // 
                // .def	DataL  = R0				; Data to write to the page buffer (must be R0/R1)
                // .def	DataH  = R1
                // 
                // .def	Ctr2L  = R2				; Block mode buffer counter backup
                // .def	Ctr2H  = R3
                // 
                // .def	temp   = R16			; Temporary registers
                // .def	temp2  = R17			; (Do not use these to save values across a subroutine call)
                // 
                // .def	delay  = R18			; Delay counter for UART_delay & byte counter for writing flash
                // .def	bitcnt = R19			; Bit counter for UART
                // 
                // .def	Hex00L = R22			; Can save code space with registers setup as a 0x0000
                // .def	Hex00H = R23			; constant for use in "out" & "movw" commands
                // 
                // .def	InstrL = R24			; Copy of an instruction
                // .def	InstrH = R25
                // 
                // .def	CtrL   = R26			; 16-bit Counter
                // .def	CtrH   = R27			; (Used for nbr of bytes in the block cmds)
                // 
                // .def	Addr2L = R28			; Address backup
                // .def	Addr2H = R29			; (Also used as the Y register for indexed access to RAM)
                // 
                // .def	AddrL  = R30			; flash/EEPROM address
                // .def	AddrH  = R31			; (Must be the Z register for indexed access to flash ROM)
                // 
                // 
                // .cseg
                // .org 0x000
@000000 ceff    // 	rjmp	bl_start
                // .org 0x001
                //  progstart:
                // 	; ***************************************************
                // 	; ******* MAIN PROGRAM WILL BE INSERTED HERE! *******
                // 	; ***************************************************
                // 
                // .org (FLASHEND+1)-(BLSIZE*PAGESIZE)
                // bl_start:
                // 	;Initialization Notes
                // 	;We only get to here after a power on reset so we use the reset defaults wherever possible to save code space
                // 	;- The interrupts are all disabled, so we don't have to worry about them.
                // 	;- We don't care what the EESAVE fuse is set to.
                // 	;- EEARH is undefined on reset but we can save code by not refering to it for the attiny25/45
                // 	;- SPH & SPL are set to RAMEND on reset for ATTiny25/45/85
                // 	;- We use the default value of the clock prescaler. If you alter this then you will need to alter the value
                // 	;  of "Freq" to match your fuse setting.
                // 
@000f00 e060    // 	ldi	Hex00L, 0x00			; Initialize our register constant 0x0000
@000f01 e070    // 	ldi	Hex00H, 0x00
                // 
@000f02 b714    // 	in temp2,	MCUSR			; Save the reset flags
@000f03 bf64    // 	out MCUSR,	Hex00L			; and immediately set them all to zero
                // 
@000f04 e108    // 	ldi temp, 	(1<<WDCE) | (1<<WDE)
@000f05 bd01    // 	out WDTCR, 	temp			; Must set MCUSR:WDRF to zero before disabling the WDT
                // 	;ldi temp, 	WATCHDOG_OFF
@000f06 bd61    // 	out WDTCR, 	Hex00L			; Need to disable the watchdog timer before we jump to the app
                // 
@000f07 fd13    // 	sbrc temp2,	WDRF			; If this was a watchdog reset
@000f08 c09b    // 	rjmp addr0					; then jump straight to the app
@000f09 e00e    // 	ldi temp, 	WATCHDOG_1S		; else enable the watchdog timer and/or set delay for the bootloader
@000f0a bd01    // 	out WDTCR, 	temp			; (Don't need to use any special procedure to enable the WDT)
                // 
@000f0b ef0f    // 	ldi	temp,0xFF				; PORTB will be initialized as all inputs after a reset
@000f0c bb08    // 	out	PORTB,temp				; Enable pullups on all input pins and TXD high when it is set as an output
                // 
@000f0d e002    // 	ldi	temp,(1<<TXD)			; Make TXD an ouput. Leave all other pins as inputs
@000f0e bb07    // 	out	DDRB,temp
                // 
                // .if ( EEPROM ) || ( AVRDUDE_Y )
                // .endif
                // 
                // 	; An extra 4 cmds (8 bytes) to change the clock frequency in software for faster downloads
                // 	; NOTE: You may need to increase the BLSIZE to cater for this
                // 	;ldi temp, (1<<CLKPCE)		; Enable clock prescaler change
                // 	;out CLKPR, temp
                // 	;ldi temp, 0x00				; Set CLKPS3:0 = 0000 for division factor =1 (8MHz) for testing
                // 	;ldi temp, 0x01				; Set CLKPS3:0 = 0001 for division factor =2 (4MHz) for testing
                // 	;ldi temp, 0x02				; Set CLKPS3:0 = 0010 for division factor =4 (2MHz) for testing
                // 	;out CLKPR, temp
                // 
                // 
                // bl_loop:
@000f0f d095    // 	rcall	getc
                // 
@000f10 3401    // 	cpi	temp, 'A'				;'A' set address
@000f11 f439    // 	brne	bl_AA
@000f12 d092    // 	rcall	getc				;MSB first
@000f13 2ff0    // 	mov	AddrH, temp
@000f14 d090    // 	rcall	getc
@000f15 2fe0    // 	mov	AddrL, temp
@000f16 0fee    // 	lsl	AddrL					;convert word address to byte address
@000f17 1fff    // 	rol	AddrH
@000f18 c088    // 	rjmp	ret_ok
                // bl_AA:
                // 
                // 
                // .if	( BLKMODE )
@000f19 3402    // 	cpi		temp, 'B'			;'B' Block Write (AddrH:AddrL is already set)
                // 	;brne	bl_GG				; block write section is too long for this relative jump
@000f1a f009    // 	breq	bl_G0
@000f1b c032    // 	rjmp	bl_GG
                // bl_G0:
@000f1c d088    // 	rcall	getc				;Number of bytes being sent: High byte
@000f1d 2fb0    // 	mov		CtrH, temp
@000f1e d086    // 	rcall	getc				;Number of bytes being sent: Low byte
@000f1f 2fa0    // 	mov		CtrL, temp
@000f20 d084    // 	rcall	getc				;Type of memory('F'lash or 'E'eprom)
@000f21 2f10    // 	mov 	temp2, temp
                // 
                // 	;Read the block of bytes into the RAM buffer
@000f22 e6c0    // 	ldi		Addr2L, LOW(SRAM_START)	;Addr2H:Addr2L used as Y reg pointing to the RAM buffer
@000f23 e0d0    // 	ldi		Addr2H, HIGH(SRAM_START)
@000f24 011d    // 	movw	Ctr2H:Ctr2L, CtrH:CtrL	;Backup CtrH:CtrL (nbr of bytes in this block cmd)
                // bl_GG1b:
@000f25 d07f    // 	rcall	getc				;Get a byte
@000f26 9309    // 	st 		Y+, temp			;and save it into the RAM buffer at this address
@000f27 9711    // 	sbiw 	CtrH:CtrL, 1		;until we've fetched CtrH:CtrH nbr of bytes
@000f28 f7e1    //    	brne	bl_GG1b
                // 
                // 	;Setup Addr2H:Addr2L and CtrH:CtrH for writing the memory (either Flash or EEPROM)
@000f29 e6c0    // 	ldi		Addr2L, LOW(SRAM_START)	;Addr2H:Addr2L used as Y reg pointing to the RAM buffer
@000f2a e0d0    // 	ldi		Addr2H, HIGH(SRAM_START)
@000f2b 01d1    // 	movw	CtrH:CtrL, Ctr2H:Ctr2L	;Restore CtrH:CtrL from backup
                // 
@000f2c 3416    // 	cpi 	temp2,'F'
                // .if ( EEPROM )
                // .else
@000f2d f521    // 	brne	ret_err1
                // .endif	; ( EEPROM )
                // 
                // 	;We are writing the program memory (Flash)
                // bl_GG2a:
                // 	;Fill the flash page buffer
@000f2e e220    // 	ldi		delay, PAGESIZE		;Counts the number of words in the flash temporary buffer
                // bl_GG2b:
@000f2f 9009    // 	ld 		DataL,Y+			;Copy the byte in the RAM buffer at Addr2H:Addr2L into DataL
@000f30 9019    // 	ld 		DataH,Y+			;Copy the byte in the RAM buffer at Addr2H:Addr2L into DataH
                // 
@000f31 30e0    // 	cpi		AddrL, 0x00			; Test if Addr is 0x0000
@000f32 07fe    // 	cpc		AddrH, AddrL
@000f33 f441    // 	brne	write_flash_1b
                // 	; Addr is 0x0000
                // 	; This is the first cmd for page 0x0000 so we update the page at addr0 here
                // 	; Read in page and exchange the nop at addr0 with the converted user program rjmp
@000f34 01c0    // 	movw	InstrH:InstrL, DataH:DataL	 ;backup instruction
@000f35 709f    // 	andi	InstrH, 0x0F		;convert app's POR rjmp cmd in InstrH:InstrL to rjmp from addr0 instead
@000f36 e00f    // 	ldi		temp, HIGH(addr0)
@000f37 5a84    // 	subi	InstrL, LOW(addr0)
@000f38 0b90    // 	sbc		InstrH, temp
@000f39 709f    // 	andi	InstrH, 0x0F
@000f3a 6c90    // 	ori		InstrH, 0xC0
@000f3b d08c    // 	rcall	firstinstr			;and rewrite the page at addr0 with the cmd in DataH:DataL at addr0
                // 	; Firstinstr() sets up new command for 0x0000: "rjmp bl_start" in DataH:DataL
                // 	; for when we fall through to next section
                // write_flash_1b:
                // 	; Addr > 0x0000
@000f3c e001    // 	ldi		temp, 0x01			;store word in DataH:DataL to the flash page buffer
@000f3d d0a1    // 	rcall	do_spm
@000f3e 9632    // 	adiw	AddrH:AddrL, 2		;increment address
@000f3f 9712    // 	sbiw 	CtrH:CtrL, 2		;Decrement our RAM buffer counter for this block by two bytes
@000f40 f011    //    	breq	bl_GG2c				;If we get to the end of this then write the flash page
@000f41 952a    // 	dec		delay				;else decrement our flash page buffer counter by 1 word
@000f42 f761    // 	brne	bl_GG2b				;looping until we fill the page buffer
                // bl_GG2c:
                // 	;Write the flash page
@000f43 e10e    // 	ldi		temp, HIGH(bl_start*2)		;Check if the address is the first page of the bootloader
@000f44 30e0    // 	cpi		AddrL, LOW(bl_start*2)
@000f45 07f0    // 	cpc		AddrH, temp
@000f46 f458    // 	brsh	ret_err1			;and exit because the app is too large to fit in the available flash
@000f47 9732    // 	sbiw	AddrH:AddrL, 2		;Point AddrH:AddrL back to the page we just wrote for call to writepage
@000f48 d093    // 	rcall	writepage
@000f49 9632    // 	adiw	AddrH:AddrL, 2		;Restore AddrH:AddrL ready for the next call to write_flash
                // 
@000f4a 30a0    // 	cpi		CtrL, 0x00			;Test if CtrH:CtrL is 0
@000f4b 07ba    // 	cpc		CtrH, CtrL
@000f4c f709    // 	brne	bl_GG2a				;If it isn't then loop back to write another page
@000f4d c053    // 	rjmp	ret_ok
                // bl_GG4:
                // .if ( EEPROM )
                // .if ( AVRDUDE_Y )				;Include the EEPROM read/write code as a subroutine
                // .else	; ( AVRDUDE_Y )			;Include the EEPROM read/write inline
                // .if   ( PAGESIZE == 32 )
                // .endif	; ( PAGESIZE == 32 )
                // .endif	; ( AVRDUDE_Y )
                // .endif	; ( EEPROM )
                // bl_GG:
                // 
                // .else	; ( BLKMODE )
                // .endif	; ( BLKMODE )
                // 
                // 
@000f4e 3504    // 	cpi	temp, 'T'				;'T' select device type
@000f4f f419    // 	brne	bl_TT				;Seems redundant in a bootloader when we also check the signature bytes
@000f50 d054    // 	rcall	getc				;Save some code by fetching the device id
@000f51 c04f    // 	rjmp	ret_ok				;and returning OK without checking
                // ret_err1:						;Need to support the blockmode relative jumps to ret_err1, even though not used by 'T' cmd.
@000f52 c04c    // 	rjmp	ret_err
                // bl_TT:
                // 
                // 
                // 
                // .if ( BLKMODE )
@000f53 3607    // 	cpi	temp, 'g'				;'g' Block Read (AddrH:AddrL is already set)
@000f54 f4f9    // 	brne	bl_g
@000f55 d04f    // 	rcall	getc				;Number of bytes being sent: High byte
@000f56 2fb0    // 	mov	CtrH, temp
@000f57 d04d    // 	rcall	getc				;Number of bytes being sent: Low byte
@000f58 2fa0    // 	mov	CtrL, temp
@000f59 d04b    // 	rcall	getc				;Type of memory('F'lash or 'E'eprom)
                // 
@000f5a 3406    // 	cpi temp,'F'
                // .if ( EEPROM )
                // .else	; ( EEPROM )
@000f5b f7b1    //     brne	ret_err1
                // .endif	; ( EEPROM )
                // 	;We are reading the program memory (Flash)
                // bl_g1:
                // 
@000f5c 30e0    // 	cpi		AddrL, 0x00			; Test if Addr is 0x0000
@000f5d 07fe    // 	cpc		AddrH, AddrL
@000f5e f469    // 	brne	bl_g2
                // 	; Address is 0x0000.
                // 	; Convert saved rjmp cmd at address addr0 to run from address 0x0000
                // 	; so that it will match the cmd at 0x0000 in the original hex file
@000f5f e4e8    // 	ldi		AddrL, LOW(addr0*2)
@000f60 e1ff    // 	ldi		AddrH, HIGH(addr0*2)
@000f61 9105    // 	lpm		temp, Z+
@000f62 9195    // 	lpm		InstrH, Z+
@000f63 709f    // 	andi	InstrH, 0x0F 		;convert rjmp target
@000f64 ef10    // 	ldi		temp2, HIGH(-addr0)
@000f65 550c    // 	subi	temp, LOW(-addr0)
@000f66 0b91    // 	sbc		InstrH, temp2
@000f67 709f    // 	andi	InstrH, 0x0F
@000f68 6c90    // 	ori		InstrH, 0xC0		;need to have low byte in temp at this stage
                // 
@000f69 e0f0    // 	ldi		AddrH, 0x00			; Set the next address to 0x0002
@000f6a e0e2    // 	ldi		AddrL, 0x02
@000f6b c002    // 	rjmp	bl_g3
                // bl_g2:
                // 	;Address is > 0x0000. Return the actual cmd at this address
@000f6c 9105    // 	lpm		temp, Z+
@000f6d 9195    // 	lpm		InstrH, Z+
                // bl_g3:
@000f6e d047    // 	rcall	putc				;return low byte
@000f6f 2f09    // 	mov		temp, InstrH
@000f70 d045    // 	rcall	putc				;return high byte
@000f71 9712    // 	sbiw CtrH:CtrL, 2			;Decrement buffer counter by one word
@000f72 f749    //    	brne	bl_g1
@000f73 cf9b    // 	rjmp	bl_loop
                // bl_g4:
                // .if ( EEPROM )
                // .if ( AVRDUDE_Y )				; Include the EEPROM read/write code as a subroutine
                // .else	; ( AVRDUDE_Y )			; Include the EEPROM read/write inline
                // .if   ( PAGESIZE == 32 )
                // .endif	; ( PAGESIZE )
                // .endif	; ( AVRDUDE_Y )
                // .endif	; ( EEPROM )
                // bl_g:
                // 
@000f74 3602    // 	cpi	temp, 'b'				;'b' support block mode reads & writes
@000f75 f431    // 	brne	bl_b
@000f76 e509    // 	ldi	temp, 'Y'				; Y = yes
@000f77 d03e    // 	rcall	putc
@000f78 e001    // 	ldi	temp, HIGH(BUFSIZE)
@000f79 d03c    // 	rcall	putc
@000f7a ec00    // 	ldi	temp, LOW(BUFSIZE)
@000f7b c026    // 	rjmp	ret_put
                // bl_b:
                // .endif	; ( BLKMODE )
                // 
                // 
                // .if ( BLKMODE && EEPROM && AVRDUDE_Y )	;Include the EEPROM read/write code as a subroutine
                // .endif	; ( BLKMODE && EEPROM && AVRDUDE_Y )
                // 
                // 
                // .if ( EEPROM && !BLKMODE ) || ( AVRDUDE_Y && !EEPROM )	;Include the EEPROM read/write code inline
                // .if   ( PAGESIZE == 32 )
                // .endif	; ( PAGESIZE )
                // .if   ( PAGESIZE == 32 )
                // .endif	; ( PAGESIZE )
                // .endif	; ( EEPROM && !BLKMODE ) || ( AVRDUDE_Y && !EEPROM )
                // 
                // 
@000f7c 3601    // 	cpi	temp, 'a'				;'a' report autoincrement address
@000f7d f411    // 	brne	bl_a
@000f7e e509    // 	ldi	temp, 'Y'
@000f7f c022    // 	rjmp	ret_put
                // bl_a:
                // 
                // 
@000f80 3703    // 	cpi	temp, 's'				;'s' read signature bytes
@000f81 f431    // 	brne	bl_s
@000f82 e00b    // 	ldi	temp, SIGNATURE_002
@000f83 d032    // 	rcall	putc
@000f84 e903    // 	ldi	temp, SIGNATURE_001
@000f85 d030    // 	rcall	putc
@000f86 e10e    // 	ldi	temp, SIGNATURE_000
@000f87 c01a    // 	rjmp	ret_put
                // bl_s:
                // 
                // 
                // .if ( !BLKMODE )
                // .endif	; ( !BLKMODE )
                // 
                // 
@000f88 3706    // 	cpi	temp, 'v'				;'v' return hardware version (redundant for bootloader)
@000f89 f059    // 	breq	bl_SS2				; Save code by returning device id, 0x00 as the hardware version
                // 
                // 
@000f8a 3506    // 	cpi	temp, 'V'				;'V' return software version
@000f8b f049    // 	breq	bl_SS2				; Save code by returning device id, 0x00 as the software version
                // 
                // 
@000f8c 3704    // 	cpi	temp, 't'				;'t' read supported device codes (redundant for bootloader)
@000f8d f039    // 	breq	bl_SS2				; Required  by avrdude. Save code space by making it the last 2 bytes of software identifier
                // 
                // 
@000f8e 3503    // 	cpi	temp, 'S'				;'S' return software identifier
@000f8f f449    // 	brne	bl_SS				; Save code by embedding the device list as the last 2 characters in the software identifier
@000f90 e015    // 	ldi		temp2,	5			; Write 'S' five times (temp2 is safe to use across a call to getc)
                // bl_SS1:
@000f91 e503    // 	ldi		temp,'S'
@000f92 d023    // 	rcall	putc
@000f93 951a    // 	dec		temp2
@000f94 f7e1    // 	brne	bl_SS1
                // bl_SS2:
@000f95 e10c    // 	ldi	temp, DevCode			; then put our list of supported device codes as the last two characters
@000f96 d01f    // 	rcall	putc
@000f97 e000    // 	ldi	temp, 0x00
@000f98 c009    // 	rjmp	ret_put
                // bl_SS:
                // 
                // 
@000f99 3605    // 	cpi	temp, 'e'				;'E' chip erase
@000f9a f031    // 	breq	ret_ok				; writepage() erases every page before writing so chip erase is functionally redundant
                // 
                // 
@000f9b 3500    // 	cpi	temp, 'P'				;'P' enter programming mode
@000f9c f021    // 	breq	ret_ok				; Redundant for bootloader
                // 
                // 
@000f9d 340c    // 	cpi	temp, 'L'				;'L' leave programming mode
@000f9e f011    // 	breq	ret_ok				;Gracefully end session with avrdude
                // 
                // 	; Save some code size by allowing ret_err to return '?' for the programmer type. Avrdude doesn't mind.
                // 
                // 
                // ;****************************** end of commands ******************************
                // ; bootloader main loop falls through to ret_err for unknown commands
                // 
                // ret_err:
@000f9f e30f    // 	ldi	temp, '?'				;unknown command or error, return '?'
@000fa0 c001    // 	rjmp	ret_put
                // 
                // ret_ok:
@000fa1 e00d    // 	ldi	temp, 13				;everything went right, return CR
                // 
                // ret_put:
@000fa2 d013    // 	rcall	putc				;return the char in temp
@000fa3 cf6b    // 	rjmp	bl_loop
                // 
                // ;************************ code to jump to application ************************
                // 
                // addr0:
                // 	;*************************************************************************
                // 				;JUMP TO USER PROGRAM (BOOTLOADER EXITS HERE)
@000fa4 cfff    // 	rjmp addr0	;gets replaced by the rjmp instr. at 0x000 in the user program
                // 				;THIS COMMAND MUST NOT BE IN THE SAME PAGE AS THE SPM COMMAND!
                // 	;*************************************************************************
                // 
                // 
                // ;***************************************************************************
                // 
                // getc:
@000fa5 e038    // 	ldi 	bitcnt,8			;8 data bits (we don't use the stop bit, so no point sampling it)
                // 
                // getc_1a:
@000fa6 9bb0    // 	sbis 	PINB,RxD			;Wait for idle
@000fa7 cffe    // 	rjmp 	getc_1a
                // 
                // getc_1b:						;Wait for start bit
@000fa8 99b0    // 	sbic 	PINB,RxD
@000fa9 cffe    // 	rjmp 	getc_1b
                // 
@000faa d019    // 	rcall UART_delay			;0.5 bit delay
                // 
                // getc_2:
@000fab d018    // 	rcall UART_delay			;1 bit delay
@000fac d017    // 	rcall UART_delay
                // 
@000fad 9488    // 	clc							;clear carry
@000fae 99b0    // 	sbic 	PINB,RxD			;if RX pin high
@000faf 9408    // 	sec					;
@000fb0 9507    // 	ror 	temp				;shift bit into temp (need to do this here if bitcnt=8)
                // 
@000fb1 95a8    // 	wdr							;Make the cycle count up to 9 for each bit
                // 
@000fb2 953a    // 	dec 	bitcnt				;If that was the 8th bit
@000fb3 f009    // 	breq 	getc_3				;   then we have finished
                // 								;else
@000fb4 cff6    // 	rjmp 	getc_2				;   go get next bit
                // 
                // getc_3:
@000fb5 9508    // 	ret
                // 
                // 
                // ;***************************************************************************
                // 
                // putc:
@000fb6 e03a    // 	ldi	bitcnt,9+sb				;1+8+sb (sb is nbr of stop bits)
@000fb7 9500    // 	com	temp					;Invert everything
@000fb8 9408    // 	sec							;Start bit
                // 
                // putc_0:
@000fb9 f410    // 	brcc	putc_1				;If carry set
@000fba 98c1    // 	cbi	PORTB,TxD				;    send a '0'
@000fbb c002    // 	rjmp	putc_2				;else
                // 
                // putc_1:
@000fbc 9ac1    // 	sbi	PORTB,TxD				;    send a '1'
@000fbd 95a8    // 	wdr							;Make the cycle count up to 9 for '1' bits
                // 
                // putc_2:
@000fbe d005    // 	rcall UART_delay			;One bit delay
@000fbf d004    // 	rcall UART_delay
                // 
@000fc0 9506    // 	lsr	temp					;Get next bit
@000fc1 953a    // 	dec	bitcnt					;If not all bit sent
@000fc2 f7b1    // 	brne	putc_0				;   send next
                // 								;else
@000fc3 9508    // 	ret							;   return
                // 
                // 
                // ;***************************************************************************
                // 
                // UART_delay:
@000fc4 e422    // 	ldi		delay,b
                // UART_delay1:
@000fc5 952a    // 	dec		delay
@000fc6 f7f1    // 	brne	UART_delay1
                // 
@000fc7 9508    // 	ret
                // 
                // 
                // 
                // .if ( BLKMODE && EEPROM && AVRDUDE_Y )	;Include the EEPROM read/write code as a subroutine
                // .if   ( PAGESIZE == 32 )
                // .endif	; ( PAGESIZE )
                // .if   ( PAGESIZE == 32 )
                // .endif	; ( PAGESIZE )
                // .endif	; ( BLKMODE && EEPROM && AVRDUDE_Y )
                // ;***************************************************************************
                // 
                // firstinstr:
@000fc8 e8e0    // 	ldi	AddrL, LOW((addr0+PAGESIZE)*2) & ~(PAGESIZE*2-1) ;Get address of the first byte of the page
@000fc9 e1ff    // 	ldi	AddrH, HIGH((addr0+PAGESIZE)*2)					 ;after the page with "addr0" in it
@000fca e210    // 	ldi	temp2, PAGESIZE
                // firstinstr_loop:
@000fcb 9731    // 	sbiw AddrH:AddrL, 1			;Fetch words from the page with "addr0" (in reverse order)
@000fcc 9014    // 	lpm	DataH, Z				;Copying the page in reverse order saves some code size because
@000fcd 9731    // 	sbiw AddrH:AddrL, 1			;it leaves AddrH:AddrL correctly set for the call to writepage
@000fce 9004    // 	lpm	DataL, Z
@000fcf 34e8    // 	cpi	AddrL, LOW(addr0*2)
@000fd0 f409    // 	brne	firstinstr_write	;until we get to "addr0"
@000fd1 010c    // 	movw	DataH:DataL, InstrH:InstrL	;when we use the contents of InstrH:InstrL instead
                // firstinstr_write:
@000fd2 e001    // 	ldi	temp, 0x01				;and copy them into the flash buffer
@000fd3 d00b    // 	rcall	do_spm
@000fd4 951a    // 	dec	temp2
@000fd5 f7a9    // 	brne	firstinstr_loop		;Until we fill the buffer
                // 
@000fd6 d005    // 	rcall	writepage			;Then write the flash page back (with the 1st pgm cmd saved@addr0)
                // 
                // 	;Reset AddrH:AddrL with 0x0000 and replace the cmd for address 0x0000 with "rjmp bl_start"
@000fd7 01fb    // 	movw	AddrH:AddrL, Hex00H:Hex00L
@000fd8 ec1e    // 	ldi	temp2, HIGH(bl_start-1) | 0xC0	;New command for 0x000: "rjmp bl_start"
@000fd9 ef0f    // 	ldi	temp, LOW(bl_start-1)
@000fda 0108    // 	movw	DataH:DataL, temp2:temp		;Return "rjmp bl_start" in DataH:DataL
@000fdb 9508    // 	ret
                // 
                // 
                // ;***************************************************************************
                // 
                // writepage:
                // 	;erases the page and writes the buffer to it
@000fdc e003    // 	ldi	temp, 0x03 				;erase page
@000fdd d001    // 	rcall	do_spm
@000fde e005    // 	ldi	temp, 0x05 				;write page
                // do_spm:
                // 	;execute the spm action specified in temp
@000fdf bf07    // 	out	SPMCSR, temp
@000fe0 95e8    // 	spm
@000fe1 9508    // 	ret
//
//Assembly complete, 0 errors, 6 warnings
